Over the eleven and a half hours I spent on this project (tracked using Hackatime!), I learned a lot about both Java programming in general, visual coding, computational physics, and myself as a programmer. Chief among these newfound knowledge gains was learning how much I loved to code. While I’d done engineering before, which I’ve always wanted to pursue in life for its applications in hardware and potential for innovation, I reinforced my supposition that pure coding gave me joy. Even when the computation and logic became very mentally intense, I loved it and was proud of my product. I believe it was this that led me to put in as much effort as I did into this project. I am glad that I saw it more as a relaxing or downtime activity than a homework assignment or school project.
Secondly, I experienced firsthand the uses, benefits, and drawbacks of AI. In order to produce my own creative thinking, I needed to manually shut off AI code completions; with the completions, I felt as if I couldn’t think. However, I found generative AI very useful when it came to concepts I did not know (as opposed to the code completions, which would complete the code I did know how to write), such as the oblique collisions and velocity exchanges I incorporated in my particle collision engine. It was also helpful in debugging, and it was especially useful for suggesting ways to optimize my code efficiency, bringing in official theoretical notation for algorithms (such as big O notation) for complexity and efficiency.
While touring others’ projects, I looked at their code. One of the projects’ output seemed visually complex, yet it had minimal lines of code—I was amazed. I realized that I, as a coder, tend to follow my thinking and code as I go rather than making an initial plan and finding the most efficient way to it. While both methods are solid, I think it may work best for me to try to limit the amount of code I write to achieve a certain outcome only after finishing a milestone (for example, the collision engine). Although I wrote a total of 388 lines, I’m sure I could reduce that and use fewer functions, methods, and class properties.
Coding is unique in the sense that it relies heavily on project-based learning. Therefore, it’s worth also mentioning that I learned and reinforced many new concepts during this project. For instance, I learned that the prime difference between arrays and ArrayLists are that arrays are fixed while ArrayLists are dynamic in sizing. I also learned that it’s helpful to mix the types—such as ArrayList<Particle>[][]—for grids, where you could have a 2D array (grid) of ArrayLists of type Particle. This allows your columns and rows to be fixed while the number of items in a certain box or index can be variable.
At first, I wanted to make something natural, satisfying, and physics-based. While I thought mixing Perlin noise color generation with collision-based physics, it turned out to be much more manageable than I had previously thought. Not only that, but I greatly enjoyed it, and I look forward to my next projects. Indeed, if I had more time, I would have added rotational velocity to provide a more realistic, swirling effect, optimized the program further for better smoothness (FPS) or detail (number of particles), and added other modes such as adding dollops of paint to the canvas.